import os
import logging
from datetime import datetime
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
import openai
import google.generativeai as genai
import re

from telegram.ext import ContextTypes

from telegram import Update
from telegram.constants import ParseMode
from urllib.parse import quote

# á€œá€±á€¬á€·á€‚á€ºá€¡á€¬á€¸ á€á€á€ºá€™á€¾á€á€ºá€á€¼á€„á€ºá€¸
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# á€•á€á€ºá€á€”á€ºá€¸á€€á€»á€„á€º á€€á€­á€”á€ºá€¸á€›á€¾á€„á€ºá€™á€»á€¬á€¸á€¡á€¬á€¸ á€–á€á€ºá€šá€°á€á€¼á€„á€ºá€¸
load_dotenv()

# á€á€šá€ºá€œá€®á€‚á€›á€™á€ºá€˜á€±á€¬á€· á€¡á€¬á€¸ á€á€á€ºá€™á€¾á€á€ºá€á€¼á€„á€ºá€¸
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

# OpenAI (ChatGPT) á€¡á€¬á€¸ á€á€á€ºá€™á€¾á€á€ºá€á€¼á€„á€ºá€¸
openai.api_key = os.getenv('OPENAI_API_KEY')

# Google Gemini AI á€¡á€¬á€¸ á€á€á€ºá€™á€¾á€á€ºá€á€¼á€„á€ºá€¸
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
genai.configure(api_key=GOOGLE_API_KEY)
gemini_model = genai.GenerativeModel('gemini-pro')

# á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€° á€™á€€á€ºá€†á€±á€·á€á€ºá€¡á€›á€±á€¡á€á€½á€€á€º
user_message_count = {}

# á€á€…á€ºá€›á€€á€ºá€¡á€á€½á€€á€º á€¡á€™á€»á€¬á€¸á€†á€¯á€¶á€¸ á€™á€€á€ºá€†á€±á€·á€á€ºá€¡á€›á€±á€¡á€á€½á€€á€º
MAX_MESSAGES_PER_DAY = 30

# á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€”á€ºá€™á€¾á€¯á€¡á€á€½á€€á€º á€…á€¬á€œá€¯á€¶á€¸á€¡á€›á€±á€¡á€á€½á€€á€º á€€á€”á€·á€ºá€á€á€ºá€á€»á€€á€º
MAX_RESPONSE_LENGTH = 2600

# á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€° input á€¡á€á€½á€€á€º á€…á€¬á€œá€¯á€¶á€¸á€¡á€›á€±á€¡á€á€½á€€á€º á€€á€”á€·á€ºá€á€á€ºá€á€»á€€á€º
MAX_USER_INPUT_LENGTH = 200

# start command handler
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # AI á€›á€½á€±á€¸á€á€»á€šá€ºá€›á€”á€º inline keyboard á€–á€”á€ºá€á€®á€¸á€á€¼á€„á€ºá€¸
    keyboard = [
        [InlineKeyboardButton("Gemini", callback_data="select_gemini"),
         InlineKeyboardButton("ChatGPT", callback_data="select_chatgpt")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # á€€á€¼á€­á€¯á€†á€­á€¯á€…á€€á€¬á€¸á€”á€¾á€„á€·á€º AI á€›á€½á€±á€¸á€á€»á€šá€ºá€›á€”á€º á€Šá€½á€¾á€”á€ºá€€á€¼á€¬á€¸á€á€»á€€á€º
    welcome_message = (
        "á€™á€„á€ºá€¹á€‚á€œá€¬á€•á€«áŠ á€€á€»á€½á€”á€ºá€á€±á€¬á€ºá€€ ASP á€–á€”á€ºá€á€®á€¸á€•á€±á€¸á€‘á€¬á€¸á€á€²á€· Tg Chat AI á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹\n"
        "á€¡á€±á€¬á€€á€ºá€™á€¾á€¬ á€•á€±á€«á€ºá€œá€¬á€á€²á€· AI á€‘á€²á€€ á€˜á€šá€º AI á€”á€²á€· á€–á€¼á€±á€…á€±á€á€»á€„á€ºá€œá€² á€›á€½á€±á€¸á€•á€±á€¸á€•á€«á‹"
    )
    
    await update.message.reply_text(welcome_message, reply_markup=reply_markup)
    logger.info(f"á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€° {update.effective_user.id} á€€ á€˜á€±á€¬á€·á€€á€­á€¯ á€…á€á€„á€ºá€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€•á€«á€á€Šá€º")

# AI model á€›á€½á€±á€¸á€á€»á€šá€ºá€™á€¾á€¯á€€á€­á€¯ á€€á€­á€¯á€„á€ºá€á€½á€šá€ºá€á€Šá€·á€º function
async def select_ai_model(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    if query.data == "select_gemini":
        context.user_data['ai_model'] = 'gemini'
        await query.edit_message_text("Gemini á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹ á€™á€±á€¸á€á€½á€”á€ºá€¸á€™á€±á€¸á€”á€­á€¯á€„á€ºá€•á€«á€•á€¼á€®á‹")
    elif query.data == "select_chatgpt":
        context.user_data['ai_model'] = 'chatgpt'
        await query.edit_message_text("ChatGPT á€€á€­á€¯ á€›á€½á€±á€¸á€á€»á€šá€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹ á€™á€±á€¸á€á€½á€”á€ºá€¸á€™á€±á€¸á€”á€­á€¯á€„á€ºá€•á€«á€•á€¼á€®á‹")

# message handler
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    current_date = datetime.now().date()

    # á€”á€±á€·á€á€…á€ºá€á€…á€ºá€›á€€á€ºá€¡á€á€½á€€á€º á€™á€€á€ºá€†á€±á€·á€á€ºá€¡á€›á€±á€¡á€á€½á€€á€ºá€¡á€¬á€¸ á€•á€¼á€”á€ºá€œá€Šá€ºá€á€á€ºá€™á€¾á€á€ºá€á€¼á€„á€ºá€¸
    if user_id not in user_message_count or user_message_count[user_id]['date'] != current_date:
        user_message_count[user_id] = {'count': 0, 'date': current_date}

    # á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€°á€á€Šá€º á€”á€±á€·á€…á€‰á€ºá€€á€”á€·á€ºá€á€á€ºá€á€»á€€á€ºá€€á€­á€¯ á€€á€»á€±á€¬á€ºá€œá€½á€”á€ºá€á€½á€¬á€¸á€á€¼á€„á€ºá€¸ á€›á€¾á€­á€™á€›á€¾á€­ á€…á€…á€ºá€†á€±á€¸á€á€¼á€„á€ºá€¸
    if user_message_count[user_id]['count'] >= MAX_MESSAGES_PER_DAY:
        await update.message.reply_text("á€šá€”á€±á€·á€¡á€á€½á€€á€º á€¡á€™á€»á€¬á€¸á€†á€¯á€¶á€¸ á€™á€€á€ºá€†á€±á€·á€á€ºá€¡á€›á€±á€¡á€á€½á€€á€ºá€á€­á€¯á€· á€›á€±á€¬á€€á€ºá€›á€¾á€­á€á€½á€¬á€¸á€•á€«á€•á€¼á€®á‹ á€”á€€á€ºá€–á€¼á€”á€ºá€á€½á€„á€º á€‘á€•á€ºá€™á€¶á€€á€¼á€­á€¯á€¸á€…á€¬á€¸á€€á€¼á€Šá€·á€ºá€•á€«á‹")
        return

    # á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€° input á€¡á€›á€¾á€Šá€ºá€€á€­á€¯ á€…á€…á€ºá€†á€±á€¸á€á€¼á€„á€ºá€¸
    if len(update.message.text) > MAX_USER_INPUT_LENGTH:
        await update.message.reply_text(f"á€á€„á€·á€ºá€™á€€á€ºá€†á€±á€·á€á€ºá€á€Šá€º á€…á€¬á€œá€¯á€¶á€¸ {MAX_USER_INPUT_LENGTH} á€‘á€€á€º á€•á€­á€¯á€›á€¾á€Šá€ºá€”á€±á€•á€«á€á€Šá€ºá‹ á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á á€á€­á€¯á€á€±á€¬á€„á€ºá€¸á€á€±á€¬ á€™á€€á€ºá€†á€±á€·á€á€ºá€€á€­á€¯ á€•á€±á€¸á€•á€­á€¯á€·á€•á€«á‹")
        return

    # á€™á€€á€ºá€†á€±á€·á€á€ºá€¡á€›á€±á€¡á€á€½á€€á€ºá€¡á€¬á€¸ á€á€­á€¯á€¸á€™á€¼á€¾á€„á€·á€ºá€á€¼á€„á€ºá€¸
    user_message_count[user_id]['count'] += 1

    # á€…á€‰á€ºá€¸á€…á€¬á€¸á€”á€±á€€á€¼á€±á€¬á€„á€ºá€¸ á€•á€¼á€á€á€¼á€„á€ºá€¸
    thinking_message = await update.message.reply_text("á€á€„á€·á€ºá€™á€±á€¸á€á€½á€”á€ºá€¸á€€á€­á€¯ á€…á€‰á€ºá€¸á€…á€¬á€¸á€”á€±á€•á€«á€á€Šá€º...")

    ai_model = context.user_data.get('ai_model', 'chatgpt')
    user_message = update.message.text

    # AI model á€”á€¾á€„á€·á€º á€á€»á€­á€á€ºá€†á€€á€ºá á€¡á€–á€¼á€±á€›á€šá€°á€á€¼á€„á€ºá€¸
    if ai_model == 'gemini':
        try:
            response = gemini_model.generate_content(user_message)
            reply_text = response.text
        except Exception as e:
            logger.error(f"Gemini AI error: {str(e)}")
            reply_text = "á€á€™á€ºá€¸á€”á€Šá€ºá€¸á€•á€«á€á€šá€ºá‹ Gemini AI á€”á€¾á€„á€·á€º á€á€»á€­á€á€ºá€†á€€á€ºá€›á€¬á€á€½á€„á€º á€•á€¼á€¿á€”á€¬ á€–á€¼á€…á€ºá€•á€±á€«á€ºá€”á€±á€•á€«á€á€Šá€ºá‹ á€á€á€œá€±á€¸ á€”á€±á€¬á€€á€ºá€™á€¾ á€‘á€•á€ºá€…á€™á€ºá€¸á€€á€¼á€Šá€·á€ºá€•á€«á‹"
    else:  # ChatGPT
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "á€™á€¼á€”á€ºá€™á€¬á€˜á€¬á€á€¬á€–á€¼á€„á€·á€º á€•á€¼á€”á€ºá€œá€Šá€ºá€á€¯á€¶á€·á€•á€¼á€”á€ºá€•á€«á‹ á€¡á€›á€±á€¸á€€á€¼á€®á€¸á€á€±á€¬ á€¡á€á€»á€€á€ºá€™á€»á€¬á€¸á€€á€­á€¯ **bold** á€–á€¼á€„á€·á€º á€–á€±á€¬á€ºá€•á€¼á€•á€«á‹ code á€™á€»á€¬á€¸á€€á€­á€¯ `inline code` á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º ```code block``` á€–á€¼á€„á€·á€º á€–á€±á€¬á€ºá€•á€¼á€•á€«á‹"},
                    {"role": "user", "content": user_message}
                ]
            )
            reply_text = response.choices[0].message.content
        except openai.error.RateLimitError:
            reply_text = "á€á€™á€ºá€¸á€”á€Šá€ºá€¸á€•á€«á€á€šá€ºá‹ á€œá€€á€ºá€›á€¾á€­á€¡á€á€»á€­á€”á€ºá€™á€¾á€¬ AI á€á€”á€ºá€†á€±á€¬á€„á€ºá€™á€¾á€¯á€€á€­á€¯ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€°á€™á€»á€¬á€¸á€”á€±á€•á€«á€á€šá€ºá‹ á€á€á€œá€±á€¸ á€”á€±á€¬á€€á€ºá€™á€¾ á€‘á€•á€ºá€…á€™á€ºá€¸á€€á€¼á€Šá€·á€ºá€•á€«á‹"
        except Exception as e:
            logger.error(f"ChatGPT error: {str(e)}")
            reply_text = "á€á€™á€ºá€¸á€”á€Šá€ºá€¸á€•á€«á€á€šá€ºá‹ AI á€”á€¾á€„á€·á€º á€á€»á€­á€á€ºá€†á€€á€ºá€›á€¬á€á€½á€„á€º á€•á€¼á€¿á€”á€¬ á€–á€¼á€…á€ºá€•á€±á€«á€ºá€”á€±á€•á€«á€á€Šá€ºá‹ á€á€á€œá€±á€¸ á€”á€±á€¬á€€á€ºá€™á€¾ á€‘á€•á€ºá€…á€™á€ºá€¸á€€á€¼á€Šá€·á€ºá€•á€«á‹"

    # Code blocks á€€á€­á€¯ á€á€®á€¸á€á€¼á€¬á€¸ format á€œá€¯á€•á€ºá€á€¼á€„á€ºá€¸
    reply_text = re.sub(r'```(\w+)?\n(.*?)\n```', lambda m: f'```{m.group(1) or ""}\n{m.group(2)}\n```', reply_text, flags=re.DOTALL)

    # á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€”á€ºá€™á€¾á€¯á€¡á€›á€¾á€Šá€ºá€€á€­á€¯ á€€á€”á€·á€ºá€á€á€ºá€á€¼á€„á€ºá€¸
    reply_text = reply_text[:MAX_RESPONSE_LENGTH]

    # á€€á€»á€”á€ºá€›á€¾á€­á€á€±á€¬ á€™á€€á€ºá€†á€±á€·á€á€ºá€¡á€›á€±á€¡á€á€½á€€á€ºá€€á€­á€¯ á€á€½á€€á€ºá€á€»á€€á€ºá€á€¼á€„á€ºá€¸
    remaining_messages = MAX_MESSAGES_PER_DAY - user_message_count[user_id]['count']

    # UI á€œá€¾á€œá€¾á€œá€±á€¸á€”á€²á€· copy á€”á€²á€· share option á€á€½á€±á€€á€­á€¯ á€‘á€Šá€·á€ºá€á€½á€„á€ºá€¸á€á€¼á€„á€ºá€¸
    keyboard = [
        [InlineKeyboardButton("ğŸ“‹ á€€á€°á€¸á€šá€°á€›á€”á€º", callback_data="copy"),
         InlineKeyboardButton("ğŸ”— á€™á€»á€¾á€á€±á€›á€”á€º", callback_data="share")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    formatted_reply = (
        f"{reply_text}\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ—¨ï¸ á€€á€»á€”á€ºá€›á€¾á€­á€á€±á€¬ á€™á€€á€ºá€†á€±á€·á€á€º: {remaining_messages}"
    )

    # á€…á€‰á€ºá€¸á€…á€¬á€¸á€”á€±á€€á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€á€á€Šá€·á€º á€™á€€á€ºá€†á€±á€·á€á€ºá€€á€­á€¯ á€–á€»á€€á€ºá€•á€…á€ºá€á€¼á€„á€ºá€¸
    await thinking_message.delete()

    # Markdown á€•á€¯á€¶á€…á€¶á€–á€¼á€„á€·á€º á€•á€¼á€”á€ºá€œá€Šá€ºá€á€¯á€¶á€·á€•á€¼á€”á€ºá€á€¼á€„á€ºá€¸
    await update.message.reply_text(formatted_reply, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    logger.info(f"á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€° {user_id} á€á€Šá€º {ai_model} á€™á€¾ á€á€¯á€¶á€·á€•á€¼á€”á€ºá€™á€¾á€¯á€á€…á€ºá€á€¯ á€›á€›á€¾á€­á€á€²á€·á€á€Šá€º")

    await update.message.reply_text(formatted_reply, reply_markup=reply_markup)
    logger.info(f"á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€á€° {user_id} á€á€Šá€º {ai_model} á€™á€¾ á€á€¯á€¶á€•á€¼á€”á€ºá€™á€¾á€¯á€á€…á€ºá€á€¯ á€›á€›á€¾á€­á€á€²á€·á€á€Šá€º")

# Copy á€œá€¯á€•á€ºá€†á€±á€¬á€„á€ºá€á€»á€€á€ºá€¡á€á€½á€€á€º callback function
async def copy_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer("á€…á€¬á€á€¬á€¸á€€á€­á€¯ á€€á€°á€¸á€šá€°á€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹")

# Share á€œá€¯á€•á€ºá€†á€±á€¬á€„á€ºá€á€»á€€á€ºá€¡á€á€½á€€á€º callback function
async def share_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    message_text = query.message.text.split("\n\n")[0]  # AI á€›á€²á€· á€¡á€–á€¼á€±á€€á€­á€¯á€•á€² á€šá€°á€•á€«á€™á€šá€º
    
    # á€…á€¬á€á€¬á€¸á€€á€­á€¯ URL encoding á€œá€¯á€•á€ºá€•á€«á€™á€šá€º
    encoded_text = quote(message_text)
    
    # Telegram share URL á€–á€”á€ºá€á€®á€¸á€•á€«á€™á€šá€º
    share_url = f"https://t.me/share/url?url={encoded_text}"
    
    share_message = (
        "á€¡á€±á€¬á€€á€ºá€•á€« link á€€á€­á€¯ á€”á€¾á€­á€•á€ºá Telegram á€™á€¾ á€á€…á€ºá€†á€„á€·á€º á€™á€»á€¾á€á€±á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹"
    )
    
    # Share á€œá€¯á€•á€ºá€›á€”á€º button á€–á€”á€ºá€á€®á€¸á€•á€«á€™á€šá€º
    keyboard = [[InlineKeyboardButton("Telegram á€™á€¾ Share á€œá€¯á€•á€ºá€›á€”á€º", url=share_url)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.answer("á€™á€»á€¾á€á€±á€”á€­á€¯á€„á€ºá€•á€«á€•á€¼á€®á‹")
    await query.edit_message_text(text=share_message, reply_markup=reply_markup)

# á€¡á€“á€­á€€ function
def main() -> None:
    # á€œá€€á€ºá€›á€¾á€­ á€”á€±á€·á€…á€½á€²á€”á€¾á€„á€·á€º á€¡á€á€»á€­á€”á€ºá€€á€­á€¯ á€á€á€ºá€™á€¾á€á€ºá€á€¼á€„á€ºá€¸
    current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    application = Application.builder().token(BOT_TOKEN).build()
    application.bot_data['current_date'] = current_date

    # Handler á€™á€»á€¬á€¸á€¡á€¬á€¸ á€‘á€Šá€·á€ºá€á€½á€„á€ºá€¸á€á€¼á€„á€ºá€¸
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(select_ai_model, pattern="^select_"))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(copy_text, pattern="^copy$"))
    application.add_handler(CallbackQueryHandler(share_text, pattern="^share$"))

    # á€˜á€±á€¬á€·á€¡á€¬á€¸ á€…á€á€„á€ºá€œá€Šá€ºá€•á€á€ºá€…á€±á€á€¼á€„á€ºá€¸
    application.run_polling()

if __name__ == '__main__':
    main()
